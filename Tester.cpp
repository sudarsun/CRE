/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "Tester.hpp"
#include "Stopwatch.hpp"
#include "LibSVMFormat.hpp"
#include "Kernel.hpp"

/**
 * http://www.nlpca.org/pca-principal-component-analysis-matlab.html
 * a = data(N,P)
 * a0 = a - mean(a)
 * [p, q, r] = princomp(a);
 * p is the coeff matrix
 * q is the transformed a
 * r is the eigen values.
 *
 * [x,y] = eig(cov(a0)) where cov(a0) = a0'*a0 / N-1
 * here x is the coefficient matrix and
 * y is the eigen values in ascending order.
 * x = x( :, end:-1:1 );
 * y = y( end:-1:1 );
 * transformed a is given by a*x;
 *
 * sign consistency change should be done! find out why..
 */

static const int kPCADimensions = 100;

void Tester::TestSparseMatrixPCA(const SparseMatrix& inMatrix, int inPCAdims, const std::string &outFileName, double& outTime)
{
	int dims = inMatrix.Columns();
	const SpMat<double> &newmat = inMatrix.Data();

	// this expression is like saying my dick is the biggest!!
	// do the centering by hand!!
	const SpMat<double> &centered = newmat - spones(newmat) * SpMat<double>(diagmat( Mat<double>( mean(newmat) ) ));

	DenseMatrix result;
	Mat<double> &eigvec = result.Data();
	Col<double> eigval;

	// extract the eigen vals and eigen vectors from the given input data matrix.
	int pcadims = std::min( dims, kPCADimensions );
	eigs_sym(eigval, eigvec, (centered.t()*centered)/(newmat.n_rows-1.0), pcadims );

	double cumsum = 0;
	int pcadim = 0;
	for ( ; pcadim < dims; ++pcadim )
	{
		double estimated_area = cumsum + (dims-pcadim) * eigval[pcadim];
		double auc = cumsum / estimated_area;
		if ( auc >= 0.9 )
			break;
	}

	// order the matrix in descending order of eigen values.
	uvec cols( pcadim );
	for ( int i = pcadim-1; i >= 0; --i ) cols[i-pcadim+1] = i;
	uvec rows( newmat.n_rows );
	for ( int i = 0; i < newmat.n_rows; ++i ) rows[i] = i;

	eigvec = eigvec.submat( rows, cols );

	result.mRows = eigvec.n_rows;
	result.mCols = eigvec.n_cols;

	std::ofstream ofile("output.libsvm");
	ofile << "EIGEN VALUES:\n" << eigval << std::endl << "SCORES\n";
	result >> ofile;

}

void Tester::TestMultivariateKernelComputation( const Matrix &s1, const Matrix &s2, double sigma, const std::string &outFileName, double &outTime )
{
	RBFKernel kernel(sigma);
	DenseMatrix K;

	Stopwatch tm;
	kernel.Compute( s1, s2, K );
	outTime = tm.Elapsed();

	std::ofstream ofile(outFileName.c_str());
	K >> ofile;
}


void Tester::TestUnivariateKernelComputation( const Matrix &s1, const Matrix &s2, double sigma, int dimId, const std::string &outFileName, double &outTime )
{
	RBFKernel kernel(sigma);
	DenseMatrix K;

	int_array cols;
	cols.push_back( dimId );

	Stopwatch tm;
	kernel.Compute( s1, s2, K, cols );
	outTime = tm.Elapsed();

	std::ofstream ofile(outFileName.c_str());
	K >> ofile;
}

void Tester::TestCrossValidationLoadSave(const cvdata_t& inCV, const std::string& inName)
{
	Data::SaveCrossValidationDataSet( inCV, inName );
	cvdata_t another;
	Data::LoadCrossValidationDataSet( inName, another );
	Data::SaveCrossValidationDataSet( another, inName + ".2" );
}

