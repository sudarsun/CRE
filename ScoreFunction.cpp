/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef __score_function_hpp__
#define __score_function_hpp__

#include "ScoreFunction.hpp"
#include "Utils.hpp"
#include <cmath>
#include <algorithm>
#include <boost/algorithm/string.hpp>

static const std::string kScoreFunctionL1Score 						= "l1score";
static const std::string kScoreFunctionBinaryClassL1Score 			= "binl1score";
static const std::string kScoreFunctionBinaryClassModifiedL1Score 	= "binmodifiedl1score";
static const std::string kScoreFunctionCorrelation 					= "correlation";
static const std::string kScoreFunctionCosine 						= "cosine";

ScoreFunction *
ScoreFunctionFactory::Create( const std::string &inName )
{
	if ( boost::algorithm::iequals( inName, kScoreFunctionL1Score ) )
		return new L1Score();
	else if ( boost::algorithm::iequals( inName, kScoreFunctionBinaryClassL1Score ) )
		return new BinaryClassL1Score();
	else if ( boost::algorithm::iequals( inName, kScoreFunctionBinaryClassModifiedL1Score ) )
		return new BinaryClassModifiedL1Score();
	else if ( boost::algorithm::iequals( inName, kScoreFunctionCorrelation ) )
		return new Correlation();
	else if ( boost::algorithm::iequals( inName, kScoreFunctionCosine ) )
		return new CosineSimilarity();

	return NULL;
}

ScoreFunction *
ScoreFunctionFactory::Create( ScorerType inType )
{
	switch (inType)
	{
		case eBinaryL1Scorer:
			return new BinaryClassL1Score();
		case eCorrelationScorer:
			return new Correlation();
		case eCosineSimiarlityScorer:
			return new CosineSimilarity();
		case eL1Scorer:
			return new L1Score();
		case eModifiedBinaryL1Scorer:
			return new BinaryClassModifiedL1Score();
	}

	return NULL;
}

float ScoreFunction::LpNorm(const real_array& ref, const real_array& test, int p) const
{
	float error = 0.0;
	for ( size_t i = 0; i < ref.size(); ++i )
		error += powf(fabs(ref[i] - test[i]), p);

	return powf(error, (1.0/p));
}

float L1Score::operator()(const real_array& ref, const real_array& test) const
{
	const float p = 1;
	float Lp = LpNorm(ref, test, p);

	// L1 norm has a range of 0.0 to 2.0^(1/p); Where 0.0 means very close and 2.0^(1/p) is completely off.
	// So, scaling it by multiplying with 2^(1/p).
	float Lpnorm = Lp / powf(2, (1.0/p));

	// similarity score is complement of L1norm.
	return 1.0 - Lpnorm;
}

float BinaryClassL1Score::operator()(const real_array &ref , const real_array &test ) const
{
	// it is analytically found that L1(ref,test) = |ref0-test0| = |ref1-test1|
	return 1 - fabs( ref[0] - test[0] );
}


float BinaryClassModifiedL1Score::operator()(const real_array &ref , const real_array &test ) const
{
	// it is analytically found that L1(ref,test) = |ref0-test0| = |ref1-test1|
	// the modified L1 is given by max( |ref0-test0|/ref0, |ref1-test1|/ref1 )
	float L1 = fabs(ref[0]-test[0]);
	return 1.0 - L1/std::max( ref[0], 1-ref[0] );

}

float Correlation::operator()(const real_array& ref, const real_array& test) const
{
	int N = ref.size();

	float mean_ref = Mean(ref), mean_test = Mean(test);
	float std_ref = StandardDeviation(ref), std_test = StandardDeviation(test);

	float sum = 0;
	for ( int i = 0; i < N; ++i )
		sum += (ref[i] - mean_ref) * (test[i] - mean_test);

	float corr = sum / ((N-1)*std_ref*std_test);
	return corr;
}

float CosineSimilarity::operator()(const real_array& ref, const real_array& test) const
{
	int N = ref.size();

	float sum_ref = 0, sum_test = 0, prod = 0;
	for ( int i = 0; i < N; ++i )
	{
		sum_ref += ref[i]*ref[i];
		sum_test += test[i]*test[i];
		prod += ref[i] * test[i];
	}

	return prod/sqrt(sum_ref * sum_test);
}

#endif // __score_function_hpp__
