/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "Matrix.hpp"
#include <cstring>
#include <sstream>
#include <cstdio>
#include <boost/algorithm/string.hpp>

bool SymmetricMatrix::Resize(int rows, int cols)
{
	mRows = rows;
	mCols = cols;
	mData.resize( rows*cols/2, 0 );
}

void SymmetricMatrix::Clear( void )
{
	mRows = mCols = 0;
	mData.clear();
}

bool
SymmetricMatrix::operator==(const SymmetricMatrix& other)
{
	if ( mRows == other.mRows and mCols == other.mCols )
	{
		if ( mData.empty() )
			return true;

		float *mine = &mData[0];
		const float *given = &(other.mData[0]);

		if ( !memcmp( mine, given, mData.size()*sizeof(float) ) )
			return true;
	}

	return false;

}	// SymmetricMatrix::operator==(const SymmetricMatrix& other)

const float & SymmetricMatrix::operator()(int r, int c) const
{
	return (*const_cast<SymmetricMatrix*>(this))(r,c);

}	// float SymmetricMatrix::operator()(int r, int c) const

float& SymmetricMatrix::operator()(int r, int c)
{
	if ( r > c )
		std::swap(r,c);

	if ( r == 0 )
		return mData[c];

	if ( r < 0 or r >= mRows )
		throw std::runtime_error("out of bounds");

	int itemsToSkip = r * ((mCols-(r-1)) + mCols)/2;

	return mData[itemsToSkip+(c-r)];

}	// float& SymmetricMatrix::operator()(int r, int c)

void SymmetricMatrix::operator<<(std::istream& is )
{
	int rows = 0, cols = 0;
	while ( is.peek() != EOF )
	{
		std::string line;
		std::getline( is, line );
		boost::trim( line );

		if ( line.empty() )
			continue;

		cols = 0;
		int skipitems = 0;
		std::stringstream ss(line);
		while ( ss.peek() != EOF )
		{
			float value;
			ss >> value;
			++cols;
			++skipitems;

			if ( skipitems > rows )
				mData.push_back(value);
		}

		++rows;
	}

	mRows = rows;
	mCols = cols;
}

void SymmetricMatrix::operator>>(std::ostream& os )
{
	int cols = mCols;
	int rows = 0;

	os << std::endl;

	int counter = cols;
	for ( int i = 0; i < mData.size(); ++i )
	{
		os << mData[i] << " ";
		if ( --counter == 0 )
		{
			os << std::endl;
			--cols;
			counter = cols;

			for ( int k = 0; k < (mCols-cols) and cols > 0; ++k )
				os << "- ";
		}
	}

	os << std::endl;
}

void SymmetricMatrix::Append( const Matrix &inMatrix )
{
	throw std::logic_error("not implemented");
}

Matrix & SymmetricMatrix::operator=( const Matrix &inMatrix )
{
	try
	{
		const SymmetricMatrix &smat = dynamic_cast<const SymmetricMatrix&>(inMatrix);
		mData = smat.mData;
		Matrix::mRows = inMatrix.Rows();
		Matrix::mCols = inMatrix.Columns();
	}
	catch( std::bad_cast & )
	{
		throw std::runtime_error( "assignment operator only defined for same matrix types" );
	}

	return *this;
}

