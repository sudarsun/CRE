/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "PCA.hpp"
#include "Stopwatch.hpp"
#include <stdexcept>

/**
 * http://math.stackexchange.com/questions/3869/what-is-the-intuitive-relationship-between-svd-and-pca
 * http://www.nlpca.org/pca-principal-component-analysis-matlab.html
 * a = data(N,P)
 * a0 = a - mean(a)
 * [p, q, r] = princomp(a);
 * p is the coeff matrix
 * q is the transformed a
 * r is the eigen values.
 *
 * [x,y] = eig(cov(a0)) where cov(a0) = a0'*a0 / N-1
 * here x is the coefficient matrix and
 * y is the eigen values in ascending order.
 * x = x( :, end:-1:1 );
 * y = y( end:-1:1 );
 * transformed a is given by a*x;
 *
 * sign consistency change should be done! find out why..
 */

static const int kPCADimensions = 100;

void PCA::Transform(const Matrix& inMatrix, const DenseMatrix& inCoeff, DenseMatrix& outTransformed)
{
	Mat<double> &mat = outTransformed.Data();

	const SparseMatrix *smat = dynamic_cast<const SparseMatrix *>(&inMatrix);
	if ( smat )
	{
		int mat_cols = smat->Columns();
		int coeff_rows = inCoeff.Rows();

		if ( coeff_rows > mat_cols )
		{
			uint_array rows(mat_cols);
			for ( int i = 0; i < mat_cols; ++i ) rows[i] = i;

			uint_array cols(inCoeff.Columns());
			for ( int i = 0; i < inCoeff.Columns(); ++i ) cols[i] = i;

			uvec r(rows), c(cols);
			mat = smat->Data() * inCoeff.Data().submat(r,c);
		}
		else
		{
			mat = smat->Data() * inCoeff.Data();
		}
	}
	else
	{
		const DenseMatrix *dmat = dynamic_cast<const DenseMatrix *>(&inMatrix);
		if ( !dmat )
			throw std::invalid_argument("PCA::Transform expects input to be either Sparse or Dense Matrix");

		int mat_cols = dmat->Columns();
		int coeff_rows = inCoeff.Rows();

		if ( coeff_rows > mat_cols )
		{
			uint_array rows(mat_cols);
			for ( int i = 0; i < mat_cols; ++i ) rows[i] = i;

			uint_array cols(inCoeff.Columns());
			for ( int i = 0; i < inCoeff.Columns(); ++i ) cols[i] = i;

			uvec r(rows), c(cols);
			mat = dmat->Data() * inCoeff.Data().submat(r,c);
		}
		else
		{
			mat = dmat->Data() * inCoeff.Data();
		}
	}

	outTransformed.mRows = mat.n_rows;
	outTransformed.mCols = mat.n_cols;
}

void PCA::Compute(const SparseMatrix& inMatrix, DenseMatrix& outCoeff, float inAUCthreshold)
{
	int dims = inMatrix.Columns();
	const SpMat<double> &newmat = inMatrix.Data();

	// this expression is like saying my dick is the biggest!!
	// do the centering by hand!!
	const SpMat<double> &centered = newmat - spones(newmat) * SpMat<double>(diagmat( Mat<double>( mean(newmat) ) ));

	Mat<double> &eigvec = outCoeff.Data();
	Col<double> eigval;

	// extract the eigen vals and eigen vectors from the given input data matrix.
	int pcadims = std::min( dims-2, kPCADimensions );
	eigs_sym(eigval, eigvec, (centered.t()*centered)/(newmat.n_rows-1.0), pcadims );

	// compute the area under the curve, by cumulative summation.
	double cumsum = 0;
	for ( int p = 0; p < pcadims; ++p ) cumsum += eigval[p];

	double auc = 0;
	int pcadim = 0;
	for ( int j = pcadims - 1; j >= 0; --j, ++pcadim )
	{
		double eval = eigval[j];
		auc += eval;

		double ratio = auc / cumsum;
		if ( ratio >= inAUCthreshold )
		{
			++pcadim;
			break;
		}
	}

	// order the matrix in descending order of eigen values.
	uint_array carray(pcadim);
	for ( int i = pcadims-1, j = 0; i >= 0 and j < pcadim; --i, ++j ) carray[j] = i;
	uvec cols( carray );

	uint_array rarray(eigvec.n_rows);
	for ( int i = 0; i < eigvec.n_rows; ++i ) rarray[i] = i;
	uvec rows( rarray );

	eigvec = eigvec.submat( rows, cols );

	outCoeff.mRows = eigvec.n_rows;
	outCoeff.mCols = eigvec.n_cols;
}

void PCA::Compute(const DenseMatrix& inMatrix, DenseMatrix& outTransformed, float inAUCthreshold)
{
	throw std::invalid_argument( "PCA::Compute(const DenseMatrix&, DenseMatrix&, float) not implemented" );
}

