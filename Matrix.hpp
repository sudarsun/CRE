/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef MATRIX_H
#define MATRIX_H

#include <iostream>
#include <utility>
#include <vector>
#include <armadillo>
#include "Typedefs.hpp"

/// Implementation of a Symmetric Matrix
class Matrix
{

public:

	Matrix() : mRows(0), mCols(0)
	{}

	virtual ~Matrix()
	{}

	bool operator==(const Matrix& other);

	virtual Matrix & operator=( const Matrix & )
	{
		throw std::logic_error("Matrix & operator=(const Matrix &) not implemented" );
	}

	/// allocate space for the matrix.
	virtual bool Resize( int rows, int cols ) = 0;

	/// const accessor method
	virtual double operator()( int r, int c ) const = 0;

	/// non-const accessor/mutator method
	virtual double & operator()( int r, int c ) = 0;

	/// read a text stream to load the matrix.
	virtual void operator << ( std::istream & ) = 0;

	/// write the matrix to an output stream
	virtual void operator >> ( std::ostream & ) const = 0;

	/// Append the matrix with the new matrix with columns size agreement.
	virtual void Append( const Matrix & ) = 0;

	virtual void Clear() = 0;

	[[nodiscard]] virtual bool Exists(int r, int c) const
	{
		return r >= 0 and r < mRows and c >= 0 and c < mCols;
	}

	[[nodiscard]] int	Rows() const
	{
		return mRows;
	}

	[[nodiscard]] int Columns() const
	{
		return mCols;
	}

	[[nodiscard]] virtual double * RawData() const
	{
		int total = mRows * mCols;
		auto *memory = new double[total];

		for (int i = 0; i < mRows; ++i)
			for (int j = 0; j < mCols; ++j)
				memory[i*mCols+j] = (*this)(i,j);

		return memory;
	}

	virtual bool	Load( const std::string &inName ) = 0;
	virtual void	Save( const std::string &inName ) const = 0;

	int mRows, mCols;				///< the dimension of the matrix.

};

using namespace arma;	/// armadillo's namespace.

class DenseMatrix : public Matrix
{

public:

	DenseMatrix() = default;

	explicit DenseMatrix( Row<double> row ) : mMatrix(std::move(row))
	{}

	explicit DenseMatrix( Col<double> col ) : mMatrix(std::move(col))
	{}

	/// constructor for pre-allocation of space.
	DenseMatrix( int rows, int cols, double value = 0 );

	~DenseMatrix() override	= default;

private:
	/// equals comparator
	bool operator==(const DenseMatrix & other);

public:
	DenseMatrix & operator+=( const DenseMatrix & );
	DenseMatrix & operator%=( const DenseMatrix & );
	DenseMatrix & operator*=( double scalar );
	DenseMatrix & operator+=( double scalar );
	DenseMatrix & operator-=( double scalar );

	/// clear the allocation.
	void Clear() override {
		mRows = mCols = 0;
		mMatrix.resize(0,0);
	}

	/// resize the matrix to (rows x cols)
	bool Resize( int rows, int cols ) override
	{
		mRows = rows, mCols = cols;
		mMatrix.resize(rows, cols);
		return true;
	}

	/// const accessor
	double operator()( int r, int c ) const override
	{
		return mMatrix(r,c);
	}

	/// non-const accessor/mutator method
	double & operator()( int r, int c ) override
	{
		return mMatrix(r,c);
	}

	/// read a text stream to load the matrix.
	void operator << ( std::istream & ) override;

	/// write the matrix to an output stream
	void operator >> ( std::ostream & ) const override;

	void Append( const Matrix & ) override;

	Matrix & operator= ( const Matrix & );

	DenseMatrix & operator=( const DenseMatrix & );

	[[nodiscard]] DenseMatrix Select( const int_array &idx1, const int_array &idx2 ) const;

	[[nodiscard]] DenseMatrix Transpose() const;

	Mat<double> & Data()
	{
		return mMatrix;
	}

	[[nodiscard]] const Mat<double> & Data() const
	{
		return mMatrix;
	}

	void Zeroize()
	{
		mMatrix.zeros();
	}

	enum Order_t
	{
		eRowWise,
		eColWise,
		eWholesome
	};

	[[nodiscard]] DenseMatrix Mean( Order_t inOrder = eColWise ) const;
	[[nodiscard]] DenseMatrix Sum( Order_t inOrder = eColWise ) const;
	[[nodiscard]] DenseMatrix Min( Order_t inOrder = eColWise ) const;
	[[nodiscard]] DenseMatrix Max( Order_t inOrder = eColWise ) const;

	bool	Load( const std::string &inName ) override;
	void	Save( const std::string &inName ) const override;

private:

	Mat<double> mMatrix;		///< Armadillo's dense matrix.

};

class IdentityMatrix : public DenseMatrix
{

public:

	IdentityMatrix(int rows, int cols) : DenseMatrix(rows, cols)
	{
		int k = std::min(rows, cols);
		for ( int i = 0; i < k; ++i )
			(*this)(i, i) = 1;
	}
};

class SparseMatrix : public Matrix
{

public:

	~SparseMatrix() override
	{}

	/// equals comparator
	bool operator==(const SparseMatrix& other);

	/// clear the allocation.
	void Clear() override;

	/// resize the matrix to (rows x cols)
	bool Resize( int rows, int cols ) override;

	/// const accessor
	double operator()( int r, int c ) const override;

	/// non-const accessor/mutator method
	double & operator()( int r, int c ) override;

	/// read a text stream to load the matrix.
	void operator << ( std::istream & ) override;

	/// write the matrix to an output stream
	void operator >> ( std::ostream & ) const override ;

	/// existence check of a cell.
	bool Exists( int row, int col ) const override;

	void Append( const Matrix & ) override;

	Matrix & operator= ( const Matrix & ) override;

	SpMat<double> & Data()
	{
		return mMatrix;
	}

	const SpMat<double> & Data() const
	{
		return mMatrix;
	}

	bool	Load( const std::string &inName ) override;
	void	Save( const std::string &inName ) const override;

private:

	SpMat<double> mMatrix;		///< Armadillo's sparse matrix.

};

#endif // MATRIX_H
