/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef MATRIX_H
#define MATRIX_H

#include <iostream>
#include <vector>
#include <armadillo>
#include "Typedefs.hpp"

/// Implementation of a Symmetric Matrix
class Matrix
{

public:

	Matrix( void ) : mRows(0), mCols(0)
	{}

	virtual ~Matrix()
	{}

	bool operator==(const Matrix& other);

	virtual Matrix & operator=( const Matrix & )
	{
		throw std::logic_error("Matrix & operator=(const Matrix &) not implemented" );
	}

	/// allocate space for the matrix.
	virtual bool Resize( int rows, int cols ) = 0;

	/// const accessor method
	virtual double operator()( int r, int c ) const = 0;

	/// non-const accessor/mutator method
	virtual double & operator()( int r, int c ) = 0;

	/// read a text stream to load the matrix.
	virtual void operator << ( std::istream & ) = 0;

	/// write the matrix to an output stream
	virtual void operator >> ( std::ostream & ) const = 0;

	/// Append the matrix with the new matrix with columns size agreement.
	virtual void Append( const Matrix & ) = 0;

	virtual void Clear( void ) = 0;

	virtual bool Exists(int r, int c) const
	{
		if ( r >= 0 and r < mRows and c >= 0 and c < mCols )
			return true;

		return false;
	}

	int	Rows( void ) const
	{
		return mRows;
	}

	int Columns( void ) const
	{
		return mCols;
	}

	virtual bool	Load( const std::string &inName ) = 0;
	virtual void	Save( const std::string &inName ) const = 0;

	int mRows, mCols;				///< the dimension of the matrix.

};

using namespace arma;	/// armadillo's namespace.

class DenseMatrix : public Matrix
{

public:

	DenseMatrix(void )
	{}

	DenseMatrix( const Row<double> &row ) : mMatrix(row)
	{}

	DenseMatrix( const Col<double> &col ) : mMatrix(col)
	{}

	/// constructor for pre-allocation of space.
	DenseMatrix( int rows, int cols, double value = 0 );

	virtual ~DenseMatrix()
	{
	}

	/// equals comparator
	bool operator==(const DenseMatrix & other);

	DenseMatrix & operator+=( const DenseMatrix & );
	DenseMatrix & operator%=( const DenseMatrix & );
	DenseMatrix & operator*=( double scalar );
	DenseMatrix & operator+=( double scalar );
	DenseMatrix & operator-=( double scalar );

	/// clear the allocation.
	void Clear( void )
	{
		mRows = mCols = 0;
		mMatrix.resize(0,0);
	}

	/// resize the matrix to (rows x cols)
	bool Resize( int rows, int cols )
	{
		mRows = rows, mCols = cols;
		mMatrix.resize(rows, cols);
		return true;
	}

	/// const accessor
	double operator()( int r, int c ) const
	{
		return mMatrix(r,c);
	}

	/// non-const accessor/mutator method
	double & operator()( int r, int c )
	{
		return mMatrix(r,c);
	}

	/// read a text stream to load the matrix.
	void operator << ( std::istream & );

	/// write the matrix to an output stream
	void operator >> ( std::ostream & ) const;

	void Append( const Matrix & );

	Matrix & operator= ( const Matrix & );

	DenseMatrix & operator=( const DenseMatrix & );

	DenseMatrix Select( const int_array &idx1, const int_array &idx2 ) const;

	DenseMatrix Transpose( void ) const;

	Mat<double> & Data( void )
	{
		return mMatrix;
	}

	const Mat<double> & Data( void ) const
	{
		return mMatrix;
	}

	void Zeroize( void )
	{
		mMatrix.zeros();
	}

	enum Order_t
	{
		eRowWise,
		eColWise,
		eWholesome
	};

	DenseMatrix Mean( Order_t inOrder = eColWise ) const;
	DenseMatrix Sum( Order_t inOrder = eColWise ) const;
	DenseMatrix Min( Order_t inOrder = eColWise ) const;
	DenseMatrix Max( Order_t inOrder = eColWise ) const;

	bool	Load( const std::string &inName );
	void	Save( const std::string &inName ) const;

private:

	Mat<double> mMatrix;		///< Armadillo's dense matrix.

};

class IdentityMatrix : public DenseMatrix
{

public:

	IdentityMatrix(int rows, int cols) : DenseMatrix(rows, cols)
	{
		int k = std::min(rows, cols);
		for ( int i = 0; i < k; ++i )
			(*this)(i, i) = 1;
	}
};

class SparseMatrix : public Matrix
{

public:

	~SparseMatrix()
	{}

	/// equals comparator
	bool operator==(const SparseMatrix& other);

	/// clear the allocation.
	void Clear( void );

	/// resize the matrix to (rows x cols)
	bool Resize( int rows, int cols );

	/// const accessor
	double operator()( int r, int c ) const;

	/// non-const accessor/mutator method
	double & operator()( int r, int c );

	/// read a text stream to load the matrix.
	void operator << ( std::istream & );

	/// write the matrix to an output stream
	void operator >> ( std::ostream & ) const;

	/// existence check of a cell.
	bool Exists( int row, int col ) const;

	void Append( const Matrix & );

	Matrix & operator= ( const Matrix & );

	SpMat<double> & Data( void )
	{
		return mMatrix;
	}

	const SpMat<double> & Data( void ) const
	{
		return mMatrix;
	}

	bool	Load( const std::string &inName );
	void	Save( const std::string &inName ) const;

private:

	SpMat<double> mMatrix;		///< Armadillo's sparse matrix.

};

#endif // MATRIX_H
