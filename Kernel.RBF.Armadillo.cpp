/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "Kernel.hpp"
#include "Stopwatch.hpp"
#include <armadillo>


/*
 * 	function [H]=rbf_dot(patterns1,patterns2, sigma);

	size1=size(patterns1);
	size2=size(patterns2);

	G = sum((patterns1.*patterns1),2);  // compute X^2
	H = sum((patterns2.*patterns2),2);  // compute Y^2

	// compute (X-Y)^2 = X^2 + Y^2 - 2XY
	H = repmat(G,1,size2(1)) + repmat(H',size1(1),1) - 2*patterns1*patterns2';

	H=exp(-H/2/sigma^2);
*/

void
RBFKernel_Armadillo::Compute( const Matrix &inA, const Matrix &inB, DenseMatrix &outKernel )
{
	using namespace arma;

	int c1 = inA.Columns(), c2 = inB.Columns();
	if ( c1 != c2 )
		throw std::runtime_error("column size disagreement");

	int n1 = inA.Rows(), n2 = inB.Rows();

	// copy the input matrices to armadillo matrices.
	Mat<float> a(n1,c1), b(n2,c1);

	// temporary storage for constructing a.*a and b.*b
	Mat<float> a2(n1,c1), b2(n2,c1);

	// copy the data and precompute a^2 and b^2
	for ( int j = 0; j < c1; ++j )
	{
		for ( int i = 0; i < n1; ++i )
		{
			float v = inA(i,j);
			a(i,j) = v;
			a2(i,j) = v*v;
		}

		for ( int i = 0; i < n2; ++i )
		{
			float v = inB(i,j);
			b(i,j) = v;
			b2(i,j) = v*v;
		}
	}

	Mat<float> temp;
	temp.ones(c1,n2);

	// repmat(sum((a.*a),2),1,n2) can be replaced by
	// ones(c1, n2) * a2
	Mat<float> H = a2 * temp;

	// free space immediately.
	a2.clear();

	// resize to ones(n1,c1)
	temp.ones(n1,c1);

	//repmat(sum((b.*b),2)',n1,1) can be replaced by
	// ones(n1,c1) * b2'
	Mat<float> G = temp * b2.t();

	// free space immediately
	b2.clear();
	temp.clear();

	// compute a*b'
	Mat<float> Q = a*b.t();

	// free space immediately
	a.clear();
	b.clear();

	// compute -2*a*b'
	Q *= -2;

	// repmat(G,1,size2(1)) + repmat(H',size1(1),1) - 2*patterns1*patterns2'
	// becomes H + G + Q
	Mat<float> P = H + G + Q;

	// free space immediately
	H.clear();
	G.clear();
	Q.clear();

	// perform exp(-P/2/sigma^2), here mScal = -1/(2*sigma^2)
	P *= mScale;
	Mat<float> J = exp(P);

	// copy the data back to return variable.
	outKernel.Resize( n1, n2 );
	for ( int i = 0; i < n1; ++i )
		for ( int j = 0; j < n2; ++j )
			outKernel(i,j) = J(i,j);
}

void
RBFKernel_Armadillo::Compute( const Matrix &inA, const Matrix &inB, DenseMatrix &outKernel, const int_array &inCols )
{
	int c1 = inA.Columns(), c2 = inB.Columns();
	if ( c1 != c2 )
		throw std::runtime_error("column size disagreement");

	int n1 = inA.Rows(), n2 = inB.Rows();
	int cx = inCols.size();

	DenseMatrix a( n1, cx ), b( n2, cx );
	for ( int c = 0; c < cx; ++c )
	{
		int col = inCols[c];
		for ( int i = 0; i < n1; ++i )
			a(i,c) = inA(i,col);
		for ( int i = 0; i < n2; ++i )
			b(i,c) = inB(i,col);
	}

	Compute( a, b, outKernel );
}
