/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "Data.hpp"
#include "LibSVMFormat.hpp"
#include "Utils.hpp"
#include <fstream>
#include <algorithm>
#include <iomanip>

Data& Data::operator=(const Data& inData )
{
	mLabels = inData.mLabels;
	mIsShallow = inData.mIsShallow;

	if ( inData.mIsShallow )
		mFeatures = new SparseMatrix();
	else
		mFeatures = new DenseMatrix();

	*mFeatures = inData.features();

	return *this;
}

bool Data::Load(const std::string& inFeatureMatrix, const std::string &inLabelColumnMatrix  )
{
	if ( inLabelColumnMatrix.empty() )
	{
		if ( LibSVMFormat::CheckFormat(inFeatureMatrix) )
		{
			mIsShallow = true;
			mFeatures = new SparseMatrix();
			bool result = LibSVMFormat::Read( inFeatureMatrix, *(dynamic_cast<SparseMatrix*>(mFeatures)), mLabels );

			//@Override: If the label is 0, this means the data point is "unlabeled"
			// if the labels are starting from 0, change that to start-by-1.
			//if ( mLabels.Rows() and mLabels.Min(DenseMatrix::eWholesome)(0,0) == 0 )
			//	mLabels += 1;

			return result;
		}

		std::ifstream features( inFeatureMatrix.c_str() );
		if ( !features.good() )
			return false;

		mFeatures = new DenseMatrix();
		*mFeatures << features;

		return true;
	}

	std::ifstream features( inFeatureMatrix.c_str() );
	if ( !features.good() )
		return false;

	std::ifstream labels( inLabelColumnMatrix.c_str() );
	if ( !labels.good() )
		return false;

	mFeatures = new DenseMatrix();
	*mFeatures << features;

	mLabels << labels;

	// if the labels are starting from 0, change that to start-by-1.
	if ( mLabels.Rows() and mLabels.Min(DenseMatrix::eWholesome)(0,0) == 0 )
		mLabels += 1;

	return true;
}

bool Data::Load( std::istream& inMatrix, std::istream& inLabelColumnMatrix)
{
	if ( inLabelColumnMatrix.peek() == EOF )
	{
		if ( LibSVMFormat::CheckFormat(inMatrix) )
		{
			mIsShallow = true;
			inMatrix.seekg( 0, std::ios::beg );
			mFeatures = new SparseMatrix();
			bool result = LibSVMFormat::Read( inMatrix, *(dynamic_cast<SparseMatrix*>(mFeatures)), mLabels );

			//@Override: If the label is 0, this means the data point is "unlabeled"
			// if the labels are starting from 0, change that to start-by-1.
			//if ( mLabels.Rows() and mLabels.Min(DenseMatrix::eWholesome)(0,0) == 0 )
			//	mLabels += 1;

			return result;
		}

		inMatrix.seekg( 0, std::ios::beg );
		mFeatures = new DenseMatrix();
		*mFeatures << inMatrix;

		return true;
	}

	mFeatures = new DenseMatrix();
	*mFeatures << inMatrix;

	mLabels << inLabelColumnMatrix;

	// if the labels are starting from 0, change that to start-by-1.
	if ( mLabels.Rows() and mLabels.Min(DenseMatrix::eWholesome)(0,0) == 0 )
		mLabels += 1;

	return true;
}

bool Data::Save(const std::string& outFile) const
{
	if ( mIsShallow )
	{
		std::ofstream file( outFile.c_str() );
		if ( !file.good() )
			return false;

		return LibSVMFormat::Write( file, *mFeatures, mLabels );
	}

	std::ofstream features( (outFile + ".features").c_str() );
	(*mFeatures) >> features;
	features.close();

	if ( mLabels.Rows())
	{
		std::ofstream labels(  (outFile + ".labels").c_str() );
		mLabels >> labels;
		labels.close();
	}

	return true;
}

Data * Data::getLabeled(void) const
{
	size_t n = mLabels.Rows();
	if (n == 0)
		return new Data();

	int_array dpts;
	for ( int i = 0; i < n; ++i )
		if ((int)mLabels(i,0) != 0)
			dpts.push_back(i);
		//else
		//	std::cerr << "i=" << i << ": " << mLabels(i,0) << std::endl;

	auto *dm = dynamic_cast<DenseMatrix *>(mFeatures);
	if (dm == nullptr)
		return new Data();

	const DenseMatrix &features = dm->Select(dpts, int_array());
	const DenseMatrix &labels = mLabels.Select(dpts, int_array());

	return new Data(&features, &labels);
}

Data * Data::getUnlabeled() const
{
	size_t n = mLabels.Rows();
	if (n == 0)
		return new Data();

	int_array dpts;
	for ( int i = 0; i < n; ++i )
		if ((int)mLabels(i,0) == 0)
			dpts.push_back(i);

	if (dpts.empty())
		return new Data();

	auto *dm = dynamic_cast<DenseMatrix *>(mFeatures);
	if (dm == nullptr)
		return new Data();

	const DenseMatrix &features = dm->Select(dpts, int_array());
	const DenseMatrix &labels = mLabels.Select(dpts, int_array());

	return new Data(&features, &labels);
}

void Data::Load(const std::string& inName)
{
	if ( LibSVMFormat::CheckFormat( inName ) )
	{
		mIsShallow = true;
		mFeatures = new SparseMatrix();
		bool result = LibSVMFormat::Read( inName, *(dynamic_cast<SparseMatrix*>(mFeatures)), mLabels );

		//@Override: If the label is 0, this means the data point is "unlabeled"
		// if the labels are starting from 0, change that to start-by-1.
		//if ( mLabels.Rows() and mLabels.Min(DenseMatrix::eWholesome)(0,0) == 0 )
		//	mLabels += 1;

		return;
	}

	std::ifstream ffile( (inName + ".features").c_str() );
	std::ifstream lfile( (inName + ".labels").c_str() );

	if ( ffile.good() )
	{
		mFeatures = new DenseMatrix();
		*mFeatures << ffile;

		if ( lfile.good() )
			mLabels << lfile;

		return;
	}

	throw std::invalid_argument("input data is neither shallow or dense");
}

Data& Data::Append(const Data& inData)
{
	if ( inData.isEmpty() )
		return *this;
	else if ( isEmpty() )
		return (*this = inData);

	mLabels.Append( inData.mLabels );
	mFeatures->Append( *(inData.mFeatures) );

	return *this;

}

void Data::RandomPermute(Data& outPermuted) const
{
	if ( isEmpty() )
		return;

	int D = mFeatures->Columns();
	int N = mFeatures->Rows();

	int_array ids;
	for ( int i = 0; i < N; ++i )
		ids.push_back(i);

	std::random_shuffle( ids.begin(), ids.end() );

	bool Yfound = mLabels.Rows() > 0;

	std::stringstream ss, labels;
	for ( int i = 0; i < N; ++i )
	{
		int r = ids[i];

		if ( Yfound )
		{
			if ( mIsShallow )
				ss << mLabels(r, 0) << " ";
			else
				labels << mLabels(r,0) << std::endl;
		}

		for ( int c = 0; c < D; ++c )
		{
			const Matrix &features = *mFeatures;
			if ( !mIsShallow )
				ss << features(r,c) <<  " ";
			if ( mFeatures->Exists(r,c) )
				ss << (c+1) << ":" << features(r,c) << " ";
		}

		ss << std::endl;
	}

	outPermuted.Load(ss, labels);
}

void Data::Split(float inPercent, Data& outSplitA, Data& outSplitB) const
{
	if ( isEmpty() )
		return;

	if ( inPercent < 1 or inPercent > 99 )
		inPercent = 50;

	int D = mFeatures->Columns();
	int N = mFeatures->Rows();
	int split1 = int(N*inPercent);
	int split2 = N - split1;

	bool Yfound = mLabels.Rows() > 0;

	// populate splitA
	{
		std::stringstream ss, labels;
		for ( int r = 0; r < split1; ++r )
		{
			if ( Yfound )
			{
				if ( mIsShallow )
					ss << mLabels(r, 0) << " ";
				else
					labels << mLabels(r,0) << std::endl;
			}

			for ( int c = 0; c < D; ++c )
			{
				const Matrix &features = *mFeatures;
				if ( !mIsShallow )
					ss << features(r,c) <<  " ";
				if ( mFeatures->Exists(r,c) )
					ss << (c+1) << ":" << features(r,c) << " ";
			}

			ss << std::endl;
		}

		outSplitA.Load(ss, labels);
	}

	// populate splitB
	{
		std::stringstream ss, labels;
		for ( int r = split1; r < N; ++r )
		{
			if ( Yfound )
			{
				if ( mIsShallow )
					ss << mLabels(r, 0) << " ";
				else
					labels << mLabels(r, 0) << std::endl;
			}

			for ( int c = 0; c < D; ++c )
			{
				const Matrix &features = *mFeatures;
				if ( !mIsShallow )
					ss << features(r,c) <<  " ";
				if ( mFeatures->Exists(r,c) )
					ss << (c+1) << ":" << features(r,c) << " ";
			}

			ss << std::endl;
		}

		outSplitB.Load(ss, labels);
	}

}

void Data::SaveCrossValidationDataSet(const cvdata_t& inCVData, const std::string& inName)
{
	for ( int i = 0; i < inCVData.size(); ++i )
	{
		char name[200];
		sprintf( name, "%s-%d.train", inName.c_str(), i+1 );
		inCVData[i].train.Save(name);

		sprintf( name, "%s-%d.test", inName.c_str(), i+1 );
		inCVData[i].test.Save(name);
	}
}

void Data::LoadCrossValidationDataSet(const std::string& inName, cvdata_t& outCVData)
{
	bool status = false;
	int i = 0;

	// don't expect the CV folds to be more than 100! sigh!
	outCVData.resize(100);

	do
	{
		char tr_name[200];
		sprintf( tr_name, "%s-%d.train", inName.c_str(), i+1 );
		char te_name[200];
		sprintf( te_name, "%s-%d.test", inName.c_str(), i+1 );

		std::ifstream ffile( tr_name ), lfile( te_name );
		status = ffile.good() and lfile.good();
		if (!status)
			break;

		dataset_t &data = outCVData[i];
		data.train.Load(tr_name);
		data.test.Load(te_name);

		++i;
	}
	while( status );

	// now reset to the actual folds.
	outCVData.resize(i);
}

void Data::getCrossValidationDataSet(int &ioFolds, cvdata_t &outCVData)
{
    // randomize timer for better randperm() functionality.
	time_t tim = time(nullptr);
	srand(tim);

	int N = mLabels.Rows();
	int D = mFeatures->Columns();

	if ( ioFolds < 3 )
		ioFolds = 3;

	int_array ids;
	for ( int i = 0; i < N; ++i )
		ids.push_back(i);

	std::random_shuffle( ids.begin(), ids.end() );
	int partition_size = int((float)N/(float)ioFolds);

	bool gotY = mLabels.Rows() > 0;

	// generate the splits
	std::vector<Data> data(ioFolds);
	for ( int p = 0, f = 0; p < N and f < ioFolds; p+=partition_size, ++f )
	{
		bool col_preserved = false;

		std::stringstream labels, features;
		for ( int id = p; id < (p+partition_size) and id < N; ++id )
		{
			int index = ids[id];
			if ( gotY )
			{
				if ( mIsShallow )
					features << mLabels(index, 0) << " ";
				else
					labels << mLabels(index, 0) << std::endl;
			}


			for ( int d = 0; d < D; ++d )
			{
				const Matrix &feat = *mFeatures;
				if ( !mIsShallow )
					features << feat(index, d) << " ";
				else if ( mFeatures->Exists( index, d ) )
				{
					features << (d+1) << ":" <<  feat(index,d) << " ";
					if ( !col_preserved and (d+1) == D )
						col_preserved = true;
				}
			}

			// preserve the column size in sparse matrices.
			if ( mIsShallow and !col_preserved )
			{
				features << D << ":0";
				col_preserved = true;
			}

			features << std::endl;
		}

		data[f].Load( features, labels );
	}

	outCVData.resize( ioFolds );

	for ( int f = 0; f < ioFolds; ++f )
	{
		outCVData[f].train = data[f];
		for ( int t = 0; t < ioFolds; ++t )
		{
			if ( t == f )
				continue;

			outCVData[f].test.Append( data[t] );
		}
	}
}

void Data::_print() const
{
	if (mFeatures)
	{
		for (int i = 1; i < 10; ++i)
		{
			for (int j = 0; j < 5; ++j)
			{
				double v = (*(const Matrix *)mFeatures)(i,j);
				printf("%f ", v);
			}

			printf("\n");
		}

		printf("\n\n");
	}
	else {
		printf("feature matrix is empty!!\n\n");
	}

}

const Matrix& Data::features() const
{
	return *mFeatures;
}

const Matrix& Data::labels() const
{
	return mLabels;
}
